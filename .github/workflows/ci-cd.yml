name: Microservices CI/CD Pipeline

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'development'
        type: choice
        options:
          - development
          - staging
          - production

jobs:
  test:
    name: Test Microservices
    runs-on: ubuntu-latest
    strategy:
      matrix:
        service: [adservice, cartservice, checkoutservice, currencyservice, emailservice, frontend, paymentservice, productcatalogservice, recommendationservice, shippingservice]
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set up language runtime for ${{ matrix.service }}
        uses: ./.github/actions/setup-${{ matrix.service }}
        if: hashFiles('.github/actions/setup-${{ matrix.service }}') != ''
        
      - name: Test ${{ matrix.service }}
        run: |
          cd src/${{ matrix.service }}
          # Detect the primary language and run appropriate tests
          if [ -f "package.json" ]; then
            npm install
            npm test
          elif [ -f "requirements.txt" ]; then
            pip install -r requirements.txt
            python -m pytest
          elif [ -f "go.mod" ]; then
            go test ./...
          elif [ -f "build.gradle" ]; then
            ./gradlew test
          elif [ -f "*.sln" ]; then
            dotnet test
          fi
        continue-on-error: true

  build:
    name: Build and Push Docker Images
    runs-on: ubuntu-latest
    needs: test
    strategy:
      matrix:
        service: [adservice, cartservice, checkoutservice, currencyservice, emailservice, frontend, paymentservice, productcatalogservice, recommendationservice, shippingservice, redis-cart]
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2
      
      - name: Login to GitHub Container Registry
        uses: docker/login-action@v2
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Build and push ${{ matrix.service }}
        uses: docker/build-push-action@v4
        with:
          context: ./src/${{ matrix.service }}
          push: ${{ github.event_name != 'pull_request' }}
          tags: |
            ghcr.io/${{ github.repository_owner }}/microservices-demo-${{ matrix.service }}:${{ github.sha }}
            ghcr.io/${{ github.repository_owner }}/microservices-demo-${{ matrix.service }}:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

  deploy:
    name: Deploy to Kubernetes
    runs-on: ubuntu-latest
    needs: build
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      
      - name: Set up kubectl
        uses: azure/setup-kubectl@v3
      
      - name: Set up Minikube
        uses: medyagh/setup-minikube@master
        with:
          driver: docker
          kubernetes-version: v1.25.3
      
      - name: Configure kubectl context
        run: |
          minikube update-context
      
      - name: Create namespace
        run: |
          kubectl create namespace shop-microservices --dry-run=client -o yaml | kubectl apply -f -
      
      - name: Update Kubernetes manifests with new image tags
        run: |
          for file in k8s/*.yaml; do
            if [[ $file != *"service-config.yaml"* && $file != *"service-secrets.yaml"* && $file != *"ingressservice.yaml"* ]]; then
              service=$(basename $file .yaml)
              
              # Skip files that don't map to built services
              if [[ $service != "redis-cart" && $service != "adservice" && $service != "cartservice" && $service != "checkoutservice" && $service != "currencyservice" && $service != "emailservice" && $service != "frontend" && $service != "paymentservice" && $service != "productcatalogservice" && $service != "recommendationservice" && $service != "shippingservice" ]]; then
                continue
              fi
              
              # Replace image with GitHub Container Registry image
              if [ "${{ github.event_name }}" != "pull_request" ]; then
                sed -i "s|image: .*$service:.*|image: ghcr.io/${{ github.repository_owner }}/microservices-demo-$service:${{ github.sha }}|g" $file
              fi
            fi
          done
      
      - name: Apply Kubernetes configurations
        run: |
          # First apply ConfigMap and Secrets
          kubectl apply -f k8s/service-config.yaml -n shop-microservices
          kubectl apply -f k8s/service-secrets.yaml -n shop-microservices
          
          # Then apply Redis
          kubectl apply -f k8s/redis-cart.yaml -n shop-microservices
          
          # Wait for Redis to be ready
          kubectl wait --for=condition=ready pod -l app=redis-cart -n shop-microservices --timeout=120s
          
          # Apply the backend services
          kubectl apply -f k8s/adservice.yaml -n shop-microservices
          kubectl apply -f k8s/cartservice.yaml -n shop-microservices
          kubectl apply -f k8s/checkoutservice.yaml -n shop-microservices
          kubectl apply -f k8s/currencyservice.yaml -n shop-microservices
          kubectl apply -f k8s/emailservice.yaml -n shop-microservices
          kubectl apply -f k8s/paymentservice.yaml -n shop-microservices
          kubectl apply -f k8s/productcatalogservice.yaml -n shop-microservices
          kubectl apply -f k8s/recommendationservice.yaml -n shop-microservices
          kubectl apply -f k8s/shippingservice.yaml -n shop-microservices
          
          # Apply frontend last
          kubectl apply -f k8s/frontend.yaml -n shop-microservices
          
          # Apply ingress
          kubectl apply -f k8s/ingressservice.yaml -n shop-microservices
      
      - name: Wait for deployment to complete
        run: |
          for deployment in $(kubectl get deployments -n shop-microservices -o jsonpath='{.items[*].metadata.name}'); do
            kubectl rollout status deployment/$deployment -n shop-microservices --timeout=180s
          done
      
      - name: Set up port forwarding
        run: |
          kubectl port-forward -n shop-microservices svc/frontend 8080:80 &
          sleep 5
      
      - name: Verify application accessibility
        run: |
          curl -s -o /dev/null -w "%{http_code}" http://localhost:8080/ | grep 200
      
      - name: Get application URL
        run: |
          minikube service frontend -n shop-microservices --url
          echo "The Online Boutique application is now accessible!"